import os
import json
import qrcode
import asyncio
import logging
from aiohttp import web
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler, PicklePersistence

# ===== ØªÙ†Ø¸ÛŒÙ…Ø§Øª =====
TOKEN = os.getenv("TOKEN")
WEBHOOK_URL = os.getenv("WEBHOOK_URL")
PORT = int(os.getenv("PORT", 8080))

ADMINS = [8122737247, 7844158638]
ADMIN_GROUP_ID = -1001234567890
CONFIG_FILE = "configs.json"
USERS_FILE = "users.txt"
ORDERS_FILE = "orders.json"
BLACKLIST_FILE = "blacklist.txt"

CARD_NUMBER = os.getenv("CARD_NUMBER", "6219861812104395")
CARD_NAME = os.getenv("CARD_NAME", "Ø³Ø¬Ø§Ø¯ Ù…Ø¤ÛŒØ¯ÛŒ")

blacklist = set()
orders = {}

# ===== logging =====
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# ===== ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ =====
def check_env():
    if not TOKEN:
        raise ValueError("âŒ TOKEN Ø¯Ø± Ù…Ø­ÛŒØ· Ø³Øª Ù†Ø´Ø¯Ù‡!")
    if not WEBHOOK_URL:
        raise ValueError("âŒ WEBHOOK_URL Ø¯Ø± Ù…Ø­ÛŒØ· Ø³Øª Ù†Ø´Ø¯Ù‡!")
    if not WEBHOOK_URL.startswith("https://"):
        raise ValueError("WEBHOOK_URL Ø¨Ø§ÛŒØ¯ HTTPS Ø¨Ø§Ø´Ù‡!")

def save_user(user_id):
    if not os.path.exists(USERS_FILE):
        open(USERS_FILE, "w", encoding="utf-8").close()
    with open(USERS_FILE, "r", encoding="utf-8") as f:
        users = set(line.strip() for line in f if line.strip())
    if str(user_id) not in users:
        with open(USERS_FILE, "a", encoding="utf-8") as f:
            f.write(str(user_id) + "\n")

def read_configs():
    if not os.path.exists(CONFIG_FILE):
        return []
    with open(CONFIG_FILE, "r", encoding="utf-8") as f:
        return json.load(f)

def save_configs(configs):
    with open(CONFIG_FILE, "w", encoding="utf-8") as f:
        json.dump(configs, f, ensure_ascii=False, indent=2)

def make_qr():
    img = qrcode.make(CARD_NUMBER)
    img.save("card_qr.png")
    return "card_qr.png"

def group_configs(configs):
    grouped = {}
    for cfg in configs:
        key = f"{cfg['Ø­Ø¬Ù…']} - {cfg['Ù…Ø¯Øª']}"
        if key not in grouped:
            grouped[key] = []
        grouped[key].append(cfg)
    return grouped

def load_orders():
    global orders
    if os.path.exists(ORDERS_FILE):
        with open(ORDERS_FILE, "r", encoding="utf-8") as f:
            orders = json.load(f)
    else:
        orders = {}

def save_orders():
    with open(ORDERS_FILE, "w", encoding="utf-8") as f:
        json.dump(orders, f, ensure_ascii=False, indent=2)

def load_blacklist():
    global blacklist
    if os.path.exists(BLACKLIST_FILE):
        with open(BLACKLIST_FILE, "r") as f:
            blacklist = set(int(line.strip()) for line in f if line.strip())
    else:
        blacklist = set()

def save_blacklist():
    with open(BLACKLIST_FILE, "w") as f:
        for user_id in blacklist:
            f.write(f"{user_id}\n")

# ===== Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§ =====
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    save_user(user_id)
    if user_id in blacklist:
        await update.message.reply_text("â›” Ø´Ù…Ø§ Ù…Ø³Ø¯ÙˆØ¯ Ø´Ø¯Ù‡â€ŒØ§ÛŒØ¯.")
        return
    keyboard = [
        [InlineKeyboardButton("ğŸ’³ Ø®Ø±ÛŒØ¯ Ú©Ø§Ù†ÙÛŒÚ¯", callback_data="buy")],
        [InlineKeyboardButton("ğŸ“ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ", callback_data="support")]
    ]
    # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¯Ú©Ù…Ù‡ Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ† ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ†â€ŒÙ‡Ø§
    if user_id in ADMINS:
        keyboard.append([InlineKeyboardButton("ğŸ”§ Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ†", callback_data="admin_panel")])
    await update.message.reply_text(
        "Ø³Ù„Ø§Ù… ğŸ‘‹\nØ¨Ù‡ Ø±Ø¨Ø§Øª ÙØ±ÙˆØ´ Ú©Ø§Ù†ÙÛŒÚ¯ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯.",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if query.data == "buy":
        await query.edit_message_text("Ù„ÛŒØ³Øª Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§...")
        qr_path = make_qr()
        await query.message.reply_photo(photo=open(qr_path, "rb"), caption=f"Ø´Ù…Ø§Ø±Ù‡ Ú©Ø§Ø±Øª: {CARD_NUMBER}\nÙ†Ø§Ù…: {CARD_NAME}")
    elif query.data == "support":
        await query.edit_message_text("Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ: @manava_vpn")
    elif query.data == "admin_panel":
        await query.edit_message_text("Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ†: Ø¯Ø± Ø­Ø§Ù„ ØªÙˆØ³Ø¹Ù‡...")  # Ø§ÛŒÙ†Ø¬Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ù…Ù†Ø·Ù‚ Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ† Ø±Ø§ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"Ø®Ø·Ø§: {context.error}")

# ===== Ù…Ø³ÛŒØ± Ù¾ÛŒÙ†Ú¯ =====
async def handle_ping(request):
    return web.Response(text="OK")

# ===== main =====
async def main():
    check_env()
    load_orders()
    load_blacklist()

    application = Application.builder().token(TOKEN).persistence(PicklePersistence("bot_data.pkl")).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, start))
    application.add_handler(CallbackQueryHandler(button_handler))
    application.add_error_handler(error_handler)

    # Ù‡Ù†Ø¯Ù„Ø± ÙˆØ¨Ù‡ÙˆÚ©
    async def webhook(request):
        try:
            data = await request.json()
            logger.info("Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù¾Ø¯ÛŒØª")
            update = Update.de_json(data, application.bot)
            await application.process_update(update)
            return web.Response(status=200)
        except Exception as e:
            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± webhook: {e}")
            return web.Response(status=400)

    # Ø§Ù¾Ù„ÛŒÚ©ÛŒØ´Ù† aiohttp
    app = web.Application()
    app.router.add_post(f"/{TOKEN}", webhook)
    app.router.add_get("/ping", handle_ping)

    # Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø³Ø±ÙˆØ±
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, "0.0.0.0", PORT)
    await site.start()

    # ØªÙ†Ø¸ÛŒÙ… ÙˆØ¨Ù‡ÙˆÚ© ØªÙ„Ú¯Ø±Ø§Ù…
    await application.bot.set_webhook(f"{WEBHOOK_URL}/{TOKEN}")

    # Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø§Ù¾Ù„ÛŒÚ©ÛŒØ´Ù†
    await application.initialize()
    await application.start()

    # Ø§Ø¬Ø±Ø§ÛŒ Ø¨ÛŒâ€ŒÙ†Ù‡Ø§ÛŒØª ØªØ§ ØªÙˆÙ‚Ù
    try:
        await asyncio.Event().wait()
    finally:
        await application.stop()
        await runner.cleanup()

if __name__ == "__main__":
    asyncio.run(main())
